[{"title":"Java相同类比较属性","date":"2021-06-04T03:10:43.000Z","url":"/2021/06/04/Java%E7%9B%B8%E5%90%8C%E7%B1%BB%E6%AF%94%E8%BE%83%E5%B1%9E%E6%80%A7/","categories":[["undefined",""]],"content":"工具类"},{"title":"Java8 异步实现","date":"2021-06-03T10:02:59.000Z","url":"/2021/06/03/Java8-%E5%BC%82%E6%AD%A5%E5%AE%9E%E7%8E%B0/","tags":[["java8","/tags/java8/"]],"categories":[["undefined",""]],"content":"Java8 异步实现CompletableFuture是替代java之前版本的异步实现而设计的类。 CompletableFuture能够将回调放到与任务不同的线程中执行，也能将回调作为继续执行的同步函数，在与任务相同的线程中执行。它避免了传统回调最大的问题，那就是能够将控制流分离到不同的事件处理器中。 CompletableFuture弥补了Future模式的缺点。在异步的任务完成后，需要用其结果继续操作时，无需等待。可以直接通过thenAccept、thenApply、thenCompose等方式将前面异步处理的结果交给另外一个异步事件处理线程来处理。 CompletableFuture的特性CompletableFuture的四个静态方法 方法名 描述 runAsync(Runnable runnable) 使用ForkJoinPool.commonPool()作为它的线程池执行异步代码。 runAsync(Runnable runnable, Executor executor) 使用指定的thread pool执行异步代码。 supplyAsync(Supplier supplier) 使用ForkJoinPool.commonPool()作为它的线程池执行异步代码，异步操作有返回值 supplyAsync(Supplier supplier, Executor executor) 使用指定的thread pool执行异步代码，异步操作有返回值 runAsync与supplyAsync的主要区别就是 runAsync返回的CompletableFuture是没有返回值的 示例代码 CompletableFuture两个立即执行异步的方法 方法名 描述 complete(T t) 完成异步执行，并返回future的结果 completeExceptionally(Throwable ex) 异步执行不正常的结束 future.get()在等待执行结果时，程序会一直block，如果此时调用complete(T t)会立即执行。 示例代码 可以看到future调用complete(T t)会立即执行。但是complete(T t)只能调用一次，后续的重复调用会失效。 如果future已经执行完毕能够返回结果，此时再调用complete(T t)则会无效。 示例代码 如果使用completeExceptionally(Throwable ex)则抛出一个异常，而不是一个成功的结果。 CompletableFuture的其他返回CompletableFuture的方法首先说明一下以Async结尾的方法都是可以异步执行的，如果指定了线程池，会在指定的线程池中执行，如果没有指定，默认会在ForkJoinPool.commonPool()中执行，下文中将会有好多类似的，都不详细解释了。 thenApply系列方法（进行变换的操作） 关键的入参只有一个Function，它是函数式接口，所以使用Lambda表示起来会更加优雅。它的入参是上一个阶段计算后的结果，返回值是经过转化后结果。 thenAccept系列方法（进行消耗的操作） thenAccept是针对结果进行消耗，因为他的入参是Consumer，有入参无返回值。 thenRun系列方法（不关心上一步操作，执行下一步操作） thenRun它的入参是一个Runnable的实例，表示当得到上一步的结果时的操作。 thenCombine系列方法（将两个CompletionStage的结果，进行转换后返回） 它需要原来的处理返回值，并且other代表的CompletionStage也要返回值之后，利用这两个返回值，进行转换后返回指定类型的值。 runAfterBoth方法系列（在两个CompletionStage都运行完后在执行操作） 不关心这两个CompletionStage的结果，只关心这两个CompletionStage执行完毕，之后在进行操作（Runnable）。 applyToEither系列方法（两个completionStage，谁计算的快，就使用哪个的结果进行转换操作） 我们现实开发场景中，总会碰到有两种渠道完成同一个事情，所以就可以调用这个方法，找一个最快的结果进行处理。 acceptEither系列方法（两个completionStage，谁计算的快，就使用哪个的结果进行消耗操作） runAfterEither系列方法（两个CompletionStage，任何一个完成都会执行下一步操作（Runnable）） exceptionStage方法（当运行时出现异常，可以通过exceptionally进行补偿） whenComplete系列方法（当运行完成时，对结果的记录。这里的完成时有两种情况，一种是正常执行，返回值。另外一种是遇到异常抛出造成程序的中断。这里为什么要说成记录，因为这几个方法都会返回CompletableFuture，当Action执行完毕后它的结果返回原始的CompletableFuture的计算结果或者返回异常。所以不会对结果产生任何的作用） 最后的方法handle系列方法（运行完成时，对结果的处理。这里的完成时有两种情况，一种是正常执行，返回值。另外一种是遇到异常抛出造成程序的中断）处理异常会比之前的两种方法好很多 当出现异常的代码示例 当没有异常出现的代码示例 "}]