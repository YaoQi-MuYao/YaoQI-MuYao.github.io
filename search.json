[{"date":"2021-11-10T10:12:57.713Z","url":"/2021/11/10/%E5%9F%BA%E4%BA%8ESocket%E4%B8%8EProxy%E4%BB%A3%E7%90%86IP%20Http%E8%AF%B7%E6%B1%82/","categories":[["undefined",""]],"content":"基于Socket与Proxy代理IP Http请求1、ip池首先需要弄个ip池用来代理ip使用(最稳定的方式就是花钱)，一般的代理ip网站都会提供获取ip的接口， 例 上述为小象代理的接口调用 2、代码实现ip代理使用socket，其实是将ip与端口的获取赋值进socket，然后赋值进代理类中 最后使用Http的调用工具去请求地址即可 这里我使用的hutool工具类请求的 3、检测请求的ip是否是代理ip 这里调用这个接口就会返回请求时的ip地址"},{"title":"HashSet 数组去重以及是否有重复","date":"2021-08-25T03:52:19.000Z","url":"/2021/08/25/HashSet-%E6%95%B0%E7%BB%84%E5%8E%BB%E9%87%8D%E4%BB%A5%E5%8F%8A%E6%98%AF%E5%90%A6%E6%9C%89%E9%87%8D%E5%A4%8D/","tags":[["java","/tags/java/"]],"categories":[["undefined",""]],"content":"HasHset 数组去重的四个方法1、使用LinkedHashSet去重 2、HashSet去重 3、HashSet检查是否存在重复数据"},{"title":"SpringBoot 注解事务使用经验","date":"2021-08-02T04:00:25.000Z","url":"/2021/08/02/SpringBoot-%E6%B3%A8%E8%A7%A3%E4%BA%8B%E5%8A%A1%E4%BD%BF%E7%94%A8%E7%BB%8F%E9%AA%8C/","tags":[["SpringBoot","/tags/SpringBoot/"]],"categories":[["undefined",""]],"content":"SpringBoot 注解事务使用经验1、当try/catch是如何回滚SpringBoot的声明式事务是需要抛出异常才可以进行捕捉，如果在代码中try/catch则不会抛出异常，所以SpringBoot提供了一种方法来解决这个问题 TransactionAspectSupport.currentTransactionStatus().setRollbackOnly(); 通过使用此方法也可以使用声明式事务进行异常的回滚"},{"title":"Centos7 MySQL 开启binlog日志","date":"2021-07-05T05:10:28.000Z","url":"/2021/07/05/Centos7-MySQL-%E5%BC%80%E5%90%AFbinlog%E6%97%A5%E5%BF%97/","tags":[["服务器","/tags/%E6%9C%8D%E5%8A%A1%E5%99%A8/"]],"categories":[["undefined",""]],"content":"MySQL 开启BinLog日志BinLog日志存储着MySQL的DDL操作语句，可以使用这些语句增量备份，即指备份新增的内容。也可以用于主从复制，主节点维护一个binlog日志，从节点从binlog中同步数据 开启binlog首先找到MySQL的配置文件my.cnf 默认MySQL的my.conf都会在/etc/my.cnf 然后修改配置 添加两个配置项 然后重启MySQL的服务 最后我们进入MySQL 进行查看是否开启成功 这样就开启成功了"},{"title":"Centos7 docker 部署nginx","date":"2021-07-02T06:12:17.000Z","url":"/2021/07/02/Centos7-docker-%E9%83%A8%E7%BD%B2nginx/","tags":[["服务器","/tags/%E6%9C%8D%E5%8A%A1%E5%99%A8/"]],"categories":[["undefined",""]],"content":"Centos7 docker 部署nginx1.前提前提需要安装docker 2.部署nginx拉去镜像 查看所有本地镜像 我本地的镜像如下 镜像拉取下来后就可以启动nginx服务 -d该参数指以守护进程运行镜像，就是后台运行镜像 -p该参数只端口号，左面的端口号为宿主机端口号，有面端口号为镜像的端口号 --name指容器的别名 记得要开启服务器的端口，可以被外网访问 3.配置Nginx将nginx的配置文件挂载到宿主机，可以方便配置nginx；先创建对应的文件夹 将需要挂在到宿主机上的配置文件复制到对应路径中 复制完成后，需修改配置文件，首先是nginx.conf 然后修改default.conf 最后删除之前的nginx容器，重新启动一个 "},{"title":"Centos7 部署docker","date":"2021-07-02T05:24:46.000Z","url":"/2021/07/02/Centos7-%E9%83%A8%E7%BD%B2docker/","tags":[["服务器","/tags/%E6%9C%8D%E5%8A%A1%E5%99%A8/"]],"categories":[["undefined",""]],"content":"Centos7 部署docker1.前提对于Centos7的系统，安装Docker需要系统内核在3.10以上 首先我们先查看系统的内核版本 如果版本到不到要求，需升级版本 2.正题进入正题，首先先使用yum安装docker 安装完成后就可以启动docker服务了 启动完成时可以用命令查看是否启动成功 我这里version信息如下、已表示启动成功 docker的默认安装路径时在/var/lib/docker，我为了方便记忆，软件一般都会放在home/data里，所以我会迁移一下软件 首先停止docker服务 然后再/home/data文件夹中创建docker文件夹、再将原docker文件迁移至新文件夹中 然后删除原doker文件夹 最后我们在/var/lib中创建docker的软连接 3.配置镜像地址docker默认的镜像仓库是国外的，如果我们使用默认的仓库下载镜像是很慢的；so配置一个国内的镜像地址 修改其内容为 最后重启docker "},{"title":"远端Centos7部署MySQL与公开端口","date":"2021-06-04T09:00:49.000Z","url":"/2021/06/04/%E8%BF%9C%E7%AB%AFCentos7%E9%83%A8%E7%BD%B2MySQL%E4%B8%8E%E5%85%AC%E5%BC%80%E7%AB%AF%E5%8F%A3/","tags":[["服务器","/tags/%E6%9C%8D%E5%8A%A1%E5%99%A8/"]],"categories":[["undefined",""]],"content":"Centos7下载安装MySQL下载命令 wget -i -c  安装命令yum -y install mysql57-community-release-el7-10.noarch.rpm 安装MySQL服务*yum -y install mysql-community-server* 设置MySQL启动MySQL服务 systemctl start mysqld.service 修改MySQL数据库用户密码 首先查到MySQL的初始密码grep &quot;password&quot; /var/log/mysqld.log 然后登陆MySQLmysql -uroot -p 登陆MySQL后执行修改该root用户的密码的sql ALTER USER &#39;root&#39;@&#39;localhost&#39; IDENTIFIED BY &#39;new password&#39;; “new password”是要新设置的密码 这样MySQL的基本设置就完成了 设置远程访问执行grant all privileges on *.* to &#39;root&#39;@&#39;%&#39; identified by &#39;password&#39; with grant option;命令，这里%是指所有IP地址都可以访问这个MySQL。 一次执行flush privileges; exit 这样MySQL设置远程访问就完成了 接下来要设置服务器， 首先将MySQL的端口开放firewall-cmd --zone=public --add-port=3306/tcp --permanent 记得要关闭防火墙systemctl stop firewalld.service 这里Centos的设置就完成了 设置阿里云的开放端口我这里使用的是阿里云的轻量级服务器与ECS的不同 轻量级服务器没有安全组这个概念，需要设置防火墙即可 进入防火墙 添加新的规则即可 ​ "},{"title":"Java相同类比较属性","date":"2021-06-04T03:10:43.000Z","url":"/2021/06/04/Java%E7%9B%B8%E5%90%8C%E7%B1%BB%E6%AF%94%E8%BE%83%E5%B1%9E%E6%80%A7/","tags":[["java","/tags/java/"]],"categories":[["undefined",""]],"content":"工具类同类对象比较各属性、不同则会放入map中 "},{"title":"Java8 异步实现","date":"2021-06-03T10:02:59.000Z","url":"/2021/06/03/Java8-%E5%BC%82%E6%AD%A5%E5%AE%9E%E7%8E%B0/","tags":[["java8","/tags/java8/"]],"categories":[["undefined",""]],"content":"Java8 异步实现CompletableFuture是替代java之前版本的异步实现而设计的类。 CompletableFuture能够将回调放到与任务不同的线程中执行，也能将回调作为继续执行的同步函数，在与任务相同的线程中执行。它避免了传统回调最大的问题，那就是能够将控制流分离到不同的事件处理器中。 CompletableFuture弥补了Future模式的缺点。在异步的任务完成后，需要用其结果继续操作时，无需等待。可以直接通过thenAccept、thenApply、thenCompose等方式将前面异步处理的结果交给另外一个异步事件处理线程来处理。 CompletableFuture的特性CompletableFuture的四个静态方法 方法名 描述 runAsync(Runnable runnable) 使用ForkJoinPool.commonPool()作为它的线程池执行异步代码。 runAsync(Runnable runnable, Executor executor) 使用指定的thread pool执行异步代码。 supplyAsync(Supplier supplier) 使用ForkJoinPool.commonPool()作为它的线程池执行异步代码，异步操作有返回值 supplyAsync(Supplier supplier, Executor executor) 使用指定的thread pool执行异步代码，异步操作有返回值 runAsync与supplyAsync的主要区别就是 runAsync返回的CompletableFuture是没有返回值的 示例代码 CompletableFuture两个立即执行异步的方法 方法名 描述 complete(T t) 完成异步执行，并返回future的结果 completeExceptionally(Throwable ex) 异步执行不正常的结束 future.get()在等待执行结果时，程序会一直block，如果此时调用complete(T t)会立即执行。 示例代码 可以看到future调用complete(T t)会立即执行。但是complete(T t)只能调用一次，后续的重复调用会失效。 如果future已经执行完毕能够返回结果，此时再调用complete(T t)则会无效。 示例代码 如果使用completeExceptionally(Throwable ex)则抛出一个异常，而不是一个成功的结果。 CompletableFuture的其他返回CompletableFuture的方法首先说明一下以Async结尾的方法都是可以异步执行的，如果指定了线程池，会在指定的线程池中执行，如果没有指定，默认会在ForkJoinPool.commonPool()中执行，下文中将会有好多类似的，都不详细解释了。 thenApply系列方法（进行变换的操作） 关键的入参只有一个Function，它是函数式接口，所以使用Lambda表示起来会更加优雅。它的入参是上一个阶段计算后的结果，返回值是经过转化后结果。 thenAccept系列方法（进行消耗的操作） thenAccept是针对结果进行消耗，因为他的入参是Consumer，有入参无返回值。 thenRun系列方法（不关心上一步操作，执行下一步操作） thenRun它的入参是一个Runnable的实例，表示当得到上一步的结果时的操作。 thenCombine系列方法（将两个CompletionStage的结果，进行转换后返回） 它需要原来的处理返回值，并且other代表的CompletionStage也要返回值之后，利用这两个返回值，进行转换后返回指定类型的值。 runAfterBoth方法系列（在两个CompletionStage都运行完后在执行操作） 不关心这两个CompletionStage的结果，只关心这两个CompletionStage执行完毕，之后在进行操作（Runnable）。 applyToEither系列方法（两个completionStage，谁计算的快，就使用哪个的结果进行转换操作） 我们现实开发场景中，总会碰到有两种渠道完成同一个事情，所以就可以调用这个方法，找一个最快的结果进行处理。 acceptEither系列方法（两个completionStage，谁计算的快，就使用哪个的结果进行消耗操作） runAfterEither系列方法（两个CompletionStage，任何一个完成都会执行下一步操作（Runnable）） exceptionStage方法（当运行时出现异常，可以通过exceptionally进行补偿） whenComplete系列方法（当运行完成时，对结果的记录。这里的完成时有两种情况，一种是正常执行，返回值。另外一种是遇到异常抛出造成程序的中断。这里为什么要说成记录，因为这几个方法都会返回CompletableFuture，当Action执行完毕后它的结果返回原始的CompletableFuture的计算结果或者返回异常。所以不会对结果产生任何的作用） 最后的方法handle系列方法（运行完成时，对结果的处理。这里的完成时有两种情况，一种是正常执行，返回值。另外一种是遇到异常抛出造成程序的中断）处理异常会比之前的两种方法好很多 当出现异常的代码示例 当没有异常出现的代码示例 "}]